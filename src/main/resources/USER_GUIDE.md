# 소진공 AI 챗봇 사용자 가이드

<p align="center">
  <img src="src/main/resources/META-INF/pluginIcon.svg" alt="Semas Chatbot Icon" width="64" height="64">
</p>

<p align="center">
  <strong>🚀 AI와 함께하는 스마트한 코딩 여행을 시작하세요!</strong>
</p>

---

## 📋 목차

1. [🔐 인증절차](#-인증절차)
2. [⚙️ 프롬프트 설정 및 URL 변경](#️-프롬프트-설정-및-url-변경)
3. [🔍 인덱싱 방식 및 실시간 인덱싱](#-인덱싱-방식-및-실시간-인덱싱)
4. [✅ 소스 수정 시 '적용'과 포맷팅 기능](#-소스-수정-시-적용과-포맷팅-기능)
5. [💡 효율적인 질문 가이드](#-효율적인-질문-가이드)

---

## 🔐 인증절차

### 1️⃣ 기본 인증 프로세스

**인증키**: `semas1@3`

#### **자동 인증 팝업**
1. IntelliJ IDEA 우측 사이드바에서 **"semasChatbot"** 아이콘 클릭
2. 🔐 **인증 팝업**이 자동으로 나타남
3. 인증키 `semas1@3` 입력
4. **확인** 버튼 클릭

#### **수동 인증**
인증 팝업이 나타나지 않는 경우:
1. 상단 **🔐 인증** 버튼 클릭
2. 인증키 입력
3. 인증 완료

### 2️⃣ 인증 상태 확인

```
✅ 인증 성공: "✅ 인증이 완료되었습니다! 자동으로 프로젝트 인덱싱을 시작합니다."
❌ 인증 실패: 다시 인증 버튼을 눌러 재시도
```

### 3️⃣ 인증 관련 기능

| 기능 | 설명 |
|------|------|
| **🔐 인증** | 현재 인증 상태 확인 및 재인증 |
| **🔄 초기화** | 인증 상태 포함 전체 초기화 |
| **자동 인덱싱** | 인증 성공 시 자동으로 프로젝트 인덱싱 시작 |

### 4️⃣ 인증 설정 파일

인증키는 `config.properties` 파일에 저장됩니다:
```properties
auth.key=semas1@3
```

---

## ⚙️ 프롬프트 설정 및 URL 변경

### 1️⃣ 프롬프트 설정

#### **프롬프트 변경 방법**
1. 상단 **⚙️ 프롬프트** 버튼 클릭
2. 새로운 시스템 프롬프트 입력
3. **확인** 클릭하여 적용

#### **추천 프롬프트 예시**

**🎯 시니어 개발자 모드:**
```
당신은 20년 경력의 시니어 Java/Kotlin 개발자입니다. 
코드 리뷰 시 성능, 보안, 유지보수성을 중점적으로 검토해주세요.
Clean Code 원칙과 SOLID 원칙을 기반으로 조언해주세요.
```

**📚 코드 교육자 모드:**
```
당신은 친절한 프로그래밍 선생님입니다. 
초보자가 이해하기 쉽게 단계별로 설명해주세요.
코드의 작동 원리와 개념을 자세히 설명해주세요.
```

**🔍 아키텍처 분석가 모드:**
```
당신은 소프트웨어 아키텍처 전문가입니다. 
코드베이스 전체의 구조와 패턴을 분석하여 설명해주세요.
디자인 패턴과 아키텍처 개선 방안을 제시해주세요.
```

### 2️⃣ LM Studio URL 변경

#### **URL 설정 방법**
1. 상단 **🌐 URL** 버튼 클릭
2. 새로운 LM Studio 서버 주소 입력
   ```
   예시: http://192.168.1.100:1234/v1
   ```
3. **확인** 클릭하여 즉시 적용

#### **기본 URL 설정**
- 기본값: `http://192.168.18.53:7777/v1`
- 실시간 변경 가능 (재시작 불필요)
- 잘못된 URL 입력 시 연결 오류 발생

#### **URL 형식 요구사항**
```
✅ 올바른 형식: http://IP주소:포트/v1
✅ 예시: http://localhost:1234/v1
✅ 예시: http://192.168.1.100:7777/v1

❌ 잘못된 형식: localhost:1234
❌ 잘못된 형식: http://localhost:1234 (v1 누락)
```

### 3️⃣ 설정 지속성

- **프롬프트**: 세션 동안 유지 (재시작 시 기본값으로 복원)
- **URL**: 실시간 변경, 세션 동안 유지
- **초기화 시**: 모든 설정이 기본값으로 복원

---

## 🔍 인덱싱 방식 및 실시간 인덱싱

### 1️⃣ 자동 인덱싱 프로세스

#### **인증 후 자동 실행**
```
🔍 프로젝트 파일을 스캔하고 있습니다...
📂 지원되는 파일 확장자: java, kt, js, ts, vue, sql, xml, yml, yaml, json
⚙️ PSI 트리를 분석하여 코드 구조를 파악합니다...
🔧 인덱싱 통계를 생성하고 있습니다...
🔄 실시간 인덱싱이 활성화되었습니다. 파일 변경사항이 자동으로 반영됩니다!
```

#### **인덱싱 완료 메시지**
```
🎉 자동 프로젝트 인덱싱이 완료되었습니다!

📊 최종 인덱싱 결과:
  ✓ 전체 코드 조각: 3,456개
  ✓ 파일: 1,247개
  ✓ 클래스: 892개
  ✓ 메서드: 2,134개
  ✓ 필드: 1,567개

💡 이제 프로젝트 코드베이스를 기반으로 한 질문에 정확하게 답변할 수 있습니다!
⚡ 실시간 모드: 파일을 수정하면 자동으로 최신 코드가 반영됩니다!
```

### 2️⃣ 실시간 인덱싱 시스템

#### **핵심 특징**
- **🔄 자동 파일 변경 감지**: 파일 생성/수정/삭제 시 자동 감지
- **⚡ 배치 처리**: 여러 파일 변경을 모아서 일괄 처리 (성능 최적화)
- **🛡️ 중복 방지**: SHA-256 해시 기반으로 불필요한 재인덱싱 방지
- **🎯 스마트 필터링**: 지원 파일만 선별적으로 인덱싱

#### **배치 처리 시스템**
```
📊 배치 처리 설정:
- 최대 배치 크기: 10개 파일
- 배치 처리 간격: 1초
- 최대 동시 작업: 3개
- 대용량 파일 제외: 10MB 이상
```

#### **해시 기반 최적화**
```
🔐 해시 시스템:
- 알고리즘: SHA-256
- 중복 인덱싱 방지율: 평균 72.6%
- 메모리 효율성: 12.34MB 사용
- 성능 향상: 27.4% 처리 시간 단축
```

### 3️⃣ 인덱싱 제어 기능

#### **Tools 메뉴 기능들**

| 기능 | 설명 | 사용 시점 |
|------|------|-----------|
| **Force Reindexing** | 전체 프로젝트 강제 재인덱싱 | 인덱스 문제 시, 대규모 변경 후 |
| **Show Indexing Statistics** | 상세 성능 메트릭 및 통계 표시 | 성능 모니터링, 문제 진단 |
| **Toggle Real-time Indexing** | 실시간 인덱싱 활성화/비활성화 | 성능 문제 시, 대용량 작업 시 |

#### **인덱싱 통계 예시**
```
=== 📊 인덱싱 서비스 상태 ===
상태: 활성
가동시간: 2시간 15분
처리된 파일: 1,247개

=== 📈 인덱싱 통계 ===
총 코드 조각: 3,456개
파일: 1,247개
클래스: 892개
메서드: 2,134개
필드: 1,567개

=== 🔐 해시 통계 ===
총 계산 횟수: 5,678회
해시 일치: 4,123회 (72.6%)
해시 불일치: 1,555회 (27.4%)
메모리 사용량: 12.34MB

=== ⚡ 성능 메트릭 ===
평균 배치 처리 시간: 1.23초
평균 파일 인덱싱 시간: 45ms
최대 배치 처리 시간: 3.45초
동시 작업 수: 2/3
```

### 4️⃣ 지원 파일 형식

#### **인덱싱 대상 파일**
```java
✅ 지원 확장자:
- Java: .java
- Kotlin: .kt
- JavaScript: .js
- TypeScript: .ts
- Vue: .vue
- SQL: .sql
- XML: .xml
- YAML: .yml, .yaml
- JSON: .json
```

#### **제외 대상**
```
❌ 제외 디렉토리:
- build/
- node_modules/
- .git/
- target/
- out/

❌ 제외 파일:
- 10MB 이상 대용량 파일
- 바이너리 파일
- 임시 파일
```

---

## ✅ 소스 수정 시 '적용'과 포맷팅 기능

### 1️⃣ 코드 수정 제안 시스템

#### **수정 제안 유형**
1. **부분 코드 수정**: 선택된 코드 조각 수정
2. **전체 파일 수정**: 파일 전체 리팩토링
3. **커서 위치 코드 삽입**: 새로운 코드 추가
4. **외부 파일 수정**: 열려있지 않은 파일 수정

### 2️⃣ 인라인 적용 시스템

#### **실시간 코드 하이라이팅**
코드 수정 제안 시 해당 영역에 **시각적 마커**가 표시됩니다:

```
📍 코드 영역에 마커 표시:
┌─────────────────────────────────────┐
│ public User findUser(Long id) {     │ ← 변경 대상 영역
│   return repository.findById(id)    │   하이라이팅 표시
│     .orElse(null);                  │
│ }                                   │
└─────────────────────────────────────┘
          ↓ 마커 클릭 시
┌─────────────────────────────────────┐
│ [✅ 적용] [❌ 거절]                   │ ← 인라인 액션 버튼
└─────────────────────────────────────┘
```

#### **적용 버튼 기능**

| 버튼 | 기능 | 동작 |
|------|------|------|
| **✅ 적용** | 변경사항을 코드에 반영 | 즉시 파일 업데이트 + 자동 포맷팅 |
| **❌ 거절** | 변경사항을 취소하고 원본 유지 | 마커 제거 + 변경사항 무시 |

### 3️⃣ 자동 포맷팅 시스템

#### **적용 후 자동 포맷팅**
코드 적용 시 자동으로 실행되는 포맷팅:

1. **IntelliJ 내장 포맷터** 우선 실행
2. **JavaScript/TypeScript**: ESLint 자동 실행 (있는 경우)
3. **Java/Kotlin**: IntelliJ Code Style 적용

#### **포맷팅 메시지**
```
✅ JavaScript/TypeScript (ESLint 있음):
"📐 ESLint 포맷팅이 적용되었습니다."

✅ JavaScript/TypeScript (ESLint 없음):
"📐 IntelliJ 포맷팅이 적용되었습니다. (ESLint가 설치되지 않음)"

✅ Java/Kotlin:
"📐 코드 포맷팅이 적용되었습니다."

❌ 지원하지 않는 파일:
"💡 해당 파일 형식은 자동 포맷팅을 지원하지 않습니다."
```

#### **ESLint 통합**
```javascript
// ESLint 자동 실행 조건:
✅ node_modules/.bin/eslint 존재
✅ JavaScript/TypeScript 파일
✅ 프로젝트 루트에서 실행

// ESLint 명령어:
eslint --fix [파일경로]
```

### 4️⃣ 코드 변경 상태 관리

#### **Pending Changes 시스템**
```kotlin
// 동시 변경 제안 관리
val pendingChanges = mutableListOf<PendingChange>()

// 변경 제안 데이터 구조
data class PendingChange(
    val originalCode: String,    // 원본 코드
    val modifiedCode: String,    // 수정된 코드
    val document: Document,      // 대상 문서
    val startOffset: Int,        // 시작 위치
    val endOffset: Int          // 끝 위치
)
```

#### **실시간 하이라이팅**
- 변경 제안된 코드 영역에 **시각적 하이라이터** 표시
- 적용/거절 후 하이라이터 자동 제거
- 여러 변경사항 동시 관리 가능

### 5️⃣ 에러 처리

#### **포맷팅 실패 시**
```
⚠️ 일반적인 오류:
"⚠️ 포맷팅 중 오류가 발생했습니다: [오류 메시지]"

⚠️ ESLint 실행 실패:
"📐 IntelliJ 포맷팅이 적용되었습니다. (ESLint 실행 실패)"

⚠️ ESLint 실행 중 오류:
"📐 IntelliJ 포맷팅이 적용되었습니다. (ESLint 실행 중 오류: [상세 오류])"
```

---

## 💡 효율적인 질문 가이드

### 1️⃣ 질문 유형별 가이드

#### **🔍 RAG 기반 코드베이스 질문 (추천)**

**✅ 효과적인 질문 예시:**
```
"이 프로젝트에서 사용자 인증은 어떻게 구현되어 있나요?"
"데이터베이스 연결과 트랜잭션 관리는 어떤 방식을 사용하나요?"
"예외 처리 패턴은 무엇을 사용하고 있나요?"
"REST API의 응답 형식은 어떻게 정의되어 있나요?"
"로깅 시스템은 어떻게 구현되어 있나요?"
"보안 관련 설정은 어디에 있나요?"
```

**❌ 비효율적인 질문 예시:**
```
"이거 뭐야?"
"코드 설명해줘"
"문제 있어?"
"에러 고쳐줘"
```

#### **🛠️ 코드 수정 요청**

**✅ 구체적인 수정 요청:**
```
"이 메서드에 null 체크와 예외 처리를 추가해주세요"
"이 클래스를 Builder 패턴으로 리팩토링해주세요"
"Spring Security를 적용해주세요"
"이 전체 파일을 Clean Code 원칙에 맞게 개선해주세요"
"JUnit 5로 테스트 코드를 작성해주세요"
```

**❌ 모호한 수정 요청:**
```
"더 좋게 만들어줘"
"최적화해줘"
"리팩토링해줘"
"고쳐줘"
```

### 2️⃣ 컨텍스트 설정 방법

#### **📁 파일 컨텍스트 설정**

**방법 1: 코드 선택**
1. 에디터에서 분석하고 싶은 코드 선택
2. 우클릭 → **"Send Selection to Chat"**
3. 질문 입력

**방법 2: 프로젝트 전체 질문** (인덱싱 완료 후)
- 별도 설정 없이 바로 질문 가능
- 자동으로 관련 코드 검색하여 답변

### 3️⃣ 질문 전략

#### **📊 단계별 접근법**

**1단계: 전체 파악**
```
"이 프로젝트의 주요 기능과 아키텍처를 설명해주세요"
"프로젝트 구조와 주요 컴포넌트는 무엇인가요?"
"사용된 기술 스택과 프레임워크는 무엇인가요?"
```

**2단계: 세부 분석**
```
"[특정 기능]은 어떻게 구현되어 있나요?"
"[특정 클래스]의 역할과 책임은 무엇인가요?"
"[특정 메서드]의 로직을 설명해주세요"
```

**3단계: 문제 해결**
```
"[특정 오류]가 발생하는 원인은 무엇인가요?"
"[성능 이슈]를 개선할 방법은 무엇인가요?"
"[보안 취약점]을 해결하는 방법은 무엇인가요?"
```

#### **🎯 목적별 질문 패턴**

**코드 리뷰:**
```
"이 코드에서 개선할 점은 무엇인가요?"
"SOLID 원칙 관점에서 이 코드를 평가해주세요"
"성능상 문제가 될 수 있는 부분은 어디인가요?"
"보안 측면에서 취약한 부분이 있나요?"
```

**디버깅:**
```
"이 코드에서 [특정 에러]가 발생하는 이유는 무엇인가요?"
"[예상과 다른 동작]이 나타나는 원인을 찾아주세요"
"로그를 분석해서 문제점을 파악해주세요"
```

**리팩토링:**
```
"이 코드를 [디자인 패턴]으로 개선해주세요"
"가독성을 높이기 위한 구조 개선 방안을 제시해주세요"
"중복 코드를 제거하고 재사용성을 높여주세요"
```

**학습:**
```
"이 코드가 동작하는 원리를 단계별로 설명해주세요"
"[특정 개념]이 이 프로젝트에서 어떻게 적용되었나요?"
"[특정 라이브러리]의 사용법을 예시와 함께 설명해주세요"
```

### 4️⃣ 응답 타입 이해

#### **🏷️ AI 응답 태그**

| 태그 | 의미 | 특징 |
|------|------|------|
| **[RAG_QUESTION]** | 코드베이스 기반 답변 | 프로젝트 내 실제 코드 참조 |
| **[GENERAL]** | 일반적인 프로그래밍 지식 | 범용적인 조언이나 설명 |
| **[Modified]** | 코드 수정 결과 | 인라인 마커와 함께 변경사항 제시 |
| **[NewCode]** | 새로운 코드 생성 | 전체 파일이나 새 기능 생성 |

#### **📖 응답 활용법**

**[RAG_QUESTION] 응답 시:**
```
=== 참조 코드 1: ChatService.kt (METHOD) ===
위치: /src/main/kotlin/.../ChatService.kt:194-211
시그니처: authenticateUser(String): Boolean

[실제 프로젝트 코드가 표시됨]

→ 이 응답은 실제 프로젝트 코드를 기반으로 한 정확한 정보
```

**[Modified] 응답 시:**
```
→ 코드에 인라인 마커가 표시되며 ✅적용/❌거절 선택 가능
→ 적용 시 자동 포맷팅 실행
```

### 5️⃣ 실전 시나리오

#### **🚀 신규 프로젝트 탐색**
```
1. "이 프로젝트는 무엇을 하는 프로젝트인가요?"
2. "주요 기능들과 모듈 구조를 설명해주세요"
3. "데이터베이스 스키마와 엔티티 관계는 어떻게 되나요?"
4. "API 엔드포인트들은 어떻게 구성되어 있나요?"
5. "테스트 코드는 어떻게 작성되어 있나요?"
```

#### **🐛 버그 수정**
```
1. 에러 발생 코드 선택 → "Send Selection to Chat"
2. "이 코드에서 [구체적 에러]가 발생합니다. 원인이 무엇인가요?"
3. "이 문제를 해결하는 방법을 구현해주세요"
4. 제안된 수정사항 검토 후 ✅적용
5. "유사한 문제를 방지하는 방법은 무엇인가요?"
```

#### **🔧 코드 개선**
```
1. 코드 선택 후 "Send Selection to Chat"
2. "이 클래스의 구조를 Clean Code 원칙에 맞게 개선해주세요"
3. "성능 최적화 가능한 부분이 있나요?"
4. "테스트 가능성을 높이는 리팩토링을 해주세요"
5. 각 제안사항 검토 후 선택적 적용
```

### 6️⃣ 주의사항

#### **❗ 피해야 할 질문**
```
❌ 너무 일반적: "코드 설명해줘"
❌ 컨텍스트 부족: "에러 고쳐줘" (어떤 에러인지 명시 필요)
❌ 복합 질문: "이 코드 분석하고 리팩토링하고 테스트도 만들어줘"
❌ 모호한 요청: "더 좋게 만들어줘"
```

#### **✅ 효과적인 질문법**
```
✅ 구체적: "NullPointerException이 발생하는 원인을 찾아주세요"
✅ 맥락 제공: "사용자 로그인 기능에서 세션 관리는 어떻게 되나요?"
✅ 단일 목적: "이 메서드의 시간 복잡도를 분석해주세요"
✅ 명확한 요청: "Builder 패턴을 적용해서 리팩토링해주세요"
```

---

<p align="center">
  <strong>🎯 스마트한 코딩의 시작, 소진공 AI 챗봇과 함께하세요!</strong>
</p>

<p align="center">
  💡 <strong>Tip:</strong> 이 가이드를 북마크해두고 필요할 때마다 참고하세요!
</p>

---

*Last updated: 2025년 1월*  
*Version: 2.0.0* - 기능 중심 구성으로 전면 개편
