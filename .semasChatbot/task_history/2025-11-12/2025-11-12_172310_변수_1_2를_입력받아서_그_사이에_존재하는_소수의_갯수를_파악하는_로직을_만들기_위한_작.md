# 작업 세션: 변수 1, 2를 입력받아서 그 사이에 존재하는 소수의 갯수를 파악하는 로직을 만들기 위한 작업목록 작성해줘.

**세션 ID**: `e826b460-3519-420d-aeea-863de3a8d64c`
**생성 시간**: 2025-11-12 17:23:10
**상태**: COMPLETED
**진행률**: 100% (5/5)

## 요구사항

변수 1, 2를 입력받아서 그 사이에 존재하는 소수의 갯수를 파악하는 로직을 만들기 위한 작업목록 작성해줘.

## 작업 목록

### 1. 사용자 입력 처리 로직 구현

- **ID**: `task_1`
- **상태**: `COMPLETED`
- **순서**: 1
- **설명**: 두 개의 변수(정수)를 사용자로부터 입력받는 기능을 구현합니다. 입력값이 유효한 숫자인지 기본적인 확인을 포함합니다. (예: 문자열 입력 시 재요청 또는 오류 처리)

**프롬프트**:
```
다음 요구사항에 따라 '사용자 입력 처리 로직 구현' 작업을 위한 상세 작업 목록을 생성해주세요.

**전체 목표:** 두 정수 변수 사이에 존재하는 소수의 개수를 파악하는 로직을 구현합니다.

**현재 작업:**
*   **제목:** 사용자 입력 처리 로직 구현
*   **설명:** 두 개의 정수 변수를 사용자로부터 입력받는 기능을 구현합니다. 입력값이 유효한 숫자인지 확인하고, 유효하지 않은 입력(예: 문자열)에 대해서는 재요청하거나 적절한 오류 처리를 포함해야 합니다.

**요구사항:**
1.  Python 언어를 사용하여 구현할 수 있는 단계별 작업 목록을 제시해주세요.
2.  각 단계는 구체적이고 실행 가능해야 합니다.
3.  입력 유효성 검사 (숫자 여부) 및 유효하지 않은 입력에 대한 재입력 로직 (예: `while` 루프, `try-except` 블록 활용)을 반드시 포함해야 합니다.
4.  최종적으로 두 개의 유효한 정수 `var1`과 `var2`를 반환하는 함수 또는 스크립트 구조를 목표로 합니다.
```

**결과**:
```
네, 요청하신 '사용자 입력 처리 로직 구현' 작업을 위한 상세 작업 목록을 Python 언어 기준으로 구체적이고 실행 가능한 단계로 제시해 드립니다.

---

### **작업 제목: 사용자 입력 처리 로직 구현**

**목표:** 두 개의 유효한 정수 `var1`과 `var2`를 사용자로부터 입력받아 반환하는 함수를 구현합니다. 입력 유효성 검사 및 유효하지 않은 입력에 대한 재입력 로직을 포함합니다.

**사용 기술:** Python

---

#### **상세 작업 목록**

**단계 1: 개발 환경 설정 및 기본 파일 생성**

1.  **Python 설치 확인:** 시스템에 Python 3.x 버전이 설치되어 있는지 확인합니다. (터미널/명령 프롬프트에서 `python --version` 또는 `python3 --version` 입력)
2.  **새 Python 파일 생성:** `user_input_handler.py`라는 이름으로 새 Python 파일을 생성합니다.
3.  **파일 헤더 및 주석 추가:** 파일 상단에 작업의 목적을 설명하는 주석을 추가합니다.

    ```python
    # user_input_handler.py
    # 목표: 사용자로부터 두 개의 유효한 정수(var1, var2)를 입력받는 로직 구현
    #       - 입력 유효성 검사 (숫자 여부)
    #       - 유효하지 않은 입력에 대한 재요청 (try-except, while 루프 활용)
    ```

**단계 2: 단일 유효 정수 입력 함수 구현 (재사용성 고려)**

*   **목표:** 사용자로부터 하나의 유효한 정수를 입력받을 때까지 반복적으로 요청하고, 유효한 정수가 입력되면 해당 값을 반환하는 헬퍼 함수를 구현합니다.

1.  **함수 정의:** `get_valid_integer(prompt_message)`라는 이름의 함수를 정의합니다. 이 함수는 사용자에게 보여줄 프롬프트 메시지를 인자로 받습니다.

    ```python
    def get_valid_integer(prompt_message):
        # ... 구현 예정 ...
    ```

2.  **무한 루프 시작:** 사용자로부터 유효한 입력을 받을 때까지 반복하기 위해 `while True:` 루프를 시작합니다.

    ```python
    def get_valid_integer(prompt_message):
        while True:
            # ... 입력 처리 및 유효성 검사 로직 ...
    ```

3.  **사용자 입력 받기:** `input()` 함수를 사용하여 사용자로부터 입력을 받습니다. 이때, 함수 인자로 받은 `prompt_message`를 사용합니다.

    ```python
    def get_valid_integer(prompt_message):
        while True:
            user_input = input(prompt_message)
            # ...
    ```

4.  **입력 유효성 검사 (try-except 활용):**
    *   `try` 블록 내에서 `int()` 함수를 사용하여 사용자 입력을 정수로 변환을 시도합니다.
    *   성공적으로 변환되면 해당 정수 값을 반환하고 (함수 종료), 루프를 `break`할 필요 없이 자연스럽게 함수가 종료됩니다.
    *   `except ValueError:` 블록을 사용하여 `int()` 변환 실패 시 (예: 사용자가 문자열 입력) 발생하는 `ValueError`를 처리합니다.
    *   `except` 블록 내에서는 사용자에게 유효하지 않은 입력임을 알리는 오류 메시지를 출력하고, 루프를 계속하여 재입력을 요청합니다.

    ```python
    def get_valid_integer(prompt_message):
        while True:
            user_input = input(prompt_message)
            try:
                # 입력값을 정수로 변환 시도
                number = int(user_input)
                # 성공 시, 변환된 정수 반환 (함수 종료)
                return number
            except ValueError:
                # 정수 변환 실패 시 (예: 문자열 입력), 오류 메시지 출력
                print("오류: 유효한 정수를 입력해주세요.")
    ```

**단계 3: 두 정수 입력 및 반환 로직 구현**

*   **목표:** `get_valid_integer` 함수를 활용하여 `var1`과 `var2` 두 개의 유효한 정수를 사용자로부터 입력받고, 이 두 값을 반환하는 메인 함수를 구현합니다.

1.  **메인 함수 정의:** `get_user_numbers()`라는 이름의 함수를 정의합니다. 이 함수는 어떤 인자도 받지 않습니다.

    ```python
    def get_user_numbers():
        # ... 구현 예정 ...
    ```

2.  **첫 번째 정수 (`var1`) 입력 받기:** `get_valid_integer` 함수를 호출하여 첫 번째 정수를 입력받고 `var1` 변수에 저장합니다. 이때 적절한 프롬프트 메시지를 전달합니다.

    ```python
    def get_user_numbers():
        var1 = get_valid_integer("첫 번째 정수를 입력하세요: ")
        # ...
    ```

3.  **두 번째 정수 (`var2`) 입력 받기:** `get_valid_integer` 함수를 호출하여 두 번째 정수를 입력받고 `var2` 변수에 저장합니다. 이때 적절한 프롬프트 메시지를 전달합니다.

    ```python
    def get_user_numbers():
        var1 = get_valid_integer("첫 번째 정수를 입력하세요: ")
        var2 = get_valid_integer("두 번째 정수를 입력하세요: ")
        # ...
    ```

4.  **두 정수 반환:** `var1`과 `var2`를 튜플 형태로 반환합니다.

    ```python
    def get_user_numbers():
        var1 = get_valid_integer("첫 번째 정수를 입력하세요: ")
        var2 = get_valid_integer("두 번째 정수를 입력하세요: ")
        return var1, var2 # 두 개의 정수를 튜플 형태로 반환
    ```

**단계 4: 스크립트 실행 구조 및 테스트**

*   **목표:** 구현된 함수들을 호출하고, 올바르게 동작하는지 확인하기 위한 테스트 코드를 추가합니다.

1.  **메인 실행 블록 추가:** Python 스크립트의 일반적인 실행 진입점인 `if __name__ == "__main__":` 블록을 추가합니다.

    ```python
    if __name__ == "__main__":
        # ... 테스트 코드 ...
    ```

2.  **함수 호출 및 결과 출력:** `get_user_numbers()` 함수를 호출하여 `var1`과 `var2`를 받아오고, 이 값들을 화면에 출력하여 올바르게 입력받았는지 확인합니다.

    ```python
    if __name__ == "__main__":
        print("두 정수 변수 사이에 존재하는 소수의 개수를 파악합니다.")
        print("--------------------------------------------------")

        # 사용자로부터 두 개의 유효한 정수 입력받기
        num1, num2 = get_user_numbers()

        # 입력받은 값 확인
        print(f"\n입력된 첫 번째 정수 (var1): {num1}")
        print(f"입력된 두 번째 정수 (var2): {num2}")
        print("--------------------------------------------------")
        print("사용자 입력 처리 로직이 성공적으로 완료되었습니다.")
        # 다음 단계: num1과 num2 사이의 소수 개수를 세는 로직 호출
    ```

3.  **스크립트 실행 및 테스트:**
    *   터미널/명령 프롬프트에서 `python user_input_handler.py`를 실행합니다.
    *   **정상 입력 테스트:** 숫자(예: `10`, `-5`, `0`)를 입력하여 올바르게 처리되는지 확인합니다.
    *   **오류 입력 테스트:** 문자열(예: `abc`, `hello`), 실수(예: `3.14`), 빈 입력 등을 입력하여 오류 메시지가 출력되고 재입력을 요청하는지 확인합니다.
    *   오류 입력 후 정상 입력을 했을 때 올바르게 진행되는지 확인합니다.

---

**예상 코드 구조 (user_input_handler.py):**

```python
# user_input_handler.py
# 목표: 사용자로부터 두 개의 유효한 정수(var1, var2)를 입력받는 로직 구현
#       - 입력 유효성 검사 (숫자 여부)
#       - 유효하지 않은 입력에 대한 재요청 (try-except, while 루프 활용)

def get_valid_integer(prompt_message):
    """
    사용자로부터 유효한 정수를 입력받을 때까지 반복적으로 요청합니다.
    유효한 정수가 입력되면 해당 값을 반환합니다.
    """
    while True:
        user_input = input(prompt_message)
        try:
            # 입력값을 정수로 변환 시도
            number = int(user_input)
            # 성공 시, 변환된 정수 반환 (함수 종료)
            return number
        except ValueError:
            # 정수 변환 실패 시 (예: 문자열, 실수 입력), 오류 메시지 출력
            print("오류: 유효한 정수를 입력해주세요.")

def get_user_numbers():
    """
    get_valid_integer 함수를 활용하여 사용자로부터 두 개의 정수를 입력받고 반환합니다.
    """
    print("\n[사용자 입력 대기]")
    var1 = get_valid_integer("첫 번째 정수를 입력하세요: ")
    var2 = get_valid_integer("두 번째 정수를 입력하세요: ")
    return var1, var2 # 두 개의 정수를 튜플 형태로 반환

if __name__ == "__main__":
    print("==================================================")
    print("  두 정수 변수 사이에 존재하는 소수의 개수를 파악합니다.")
    print("  초기 단계: 사용자 입력 처리 로직 테스트")
    print("==================================================")

    # 사용자로부터 두 개의 유효한 정수 입력받기
    num1, num2 = get_user_numbers()

    # 입력받은 값 확인
    print("\n==================================================")
    print("  사용자 입력 처리 로직이 성공적으로 완료되었습니다.")
    print(f"  입력된 첫 번째 정수 (var1): {num1}")
    print(f"  입력된 두 번째 정수 (var2): {num2}")
    print("==================================================")
    print("\n다음 단계: 입력받은 두 정수 사이의 소수 개수를 세는 로직을 구현합니다.")

```
```

---

### 2. 입력 값 유효성 검사 및 정렬 로직 구현

- **ID**: `task_2`
- **상태**: `COMPLETED`
- **순서**: 2
- **설명**: 입력받은 두 변수가 올바른 정수 범위(소수 판별을 위해 2 이상)에 있는지 검사하고, 첫 번째 변수가 두 번째 변수보다 작거나 같도록 정렬하는 로직을 구현합니다. (예: `min_val`, `max_val` 변수 설정 및 값 교환 처리)

**프롬프트**:
```
당신은 두 변수 사이에 존재하는 소수의 개수를 파악하는 로직을 개발하는 프로젝트를 수행하고 있습니다.

이전 작업인 '사용자 입력 처리 로직 구현'을 통해 사용자로부터 두 개의 정수 `var1`과 `var2`를 성공적으로 입력받았다고 가정합니다.

다음 작업인 '입력 값 유효성 검사 및 정렬 로직 구현'에 대한 상세 작업 목록을 Python 언어 기준으로 구체적이고 실행 가능한 단계로 생성해주세요.

**현재 작업 목표:**
1.  입력받은 `var1`과 `var2`가 소수 판별을 위해 각각 2 이상의 정수인지 검사합니다.
2.  `var1`이 `var2`보다 큰 경우, 두 변수의 값을 교환하여 항상 `var1 <= var2`가 되도록 정렬합니다. 이후 이 값들을 각각 `min_val`과 `max_val`로 명명합니다.
3.  유효성 검사 실패 시 (예: 2 미만인 값), 적절한 오류 처리 로직을 포함합니다 (예: 예외 발생 또는 사용자에게 재입력 안내).

**생성할 작업 목록은 다음 요구사항을 충족해야 합니다:**
*   단계별로 명확하게 설명되어야 합니다.
*   구체적이고 실행 가능한 로직 구현 단계여야 합니다.
*   Python 언어 및 환경을 고려해야 합니다.
```

**결과**:
```
네, '입력 값 유효성 검사 및 정렬 로직 구현'에 대한 상세 작업 목록을 Python 언어 기준으로 구체적이고 실행 가능한 단계로 생성해 드리겠습니다.

---

### **프로젝트: 두 변수 사이 소수 개수 파악 로직 개발**
**현재 작업: 입력 값 유효성 검사 및 정렬 로직 구현**

**목표:** 사용자로부터 입력받은 `var1`, `var2`에 대해 2 이상의 정수인지 유효성 검사를 수행하고, 항상 `min_val <= max_val`이 되도록 정렬하여 `min_val`과 `max_val`을 최종적으로 준비합니다. 유효성 검사 실패 시 적절한 오류 처리를 포함합니다.

---

#### **작업 목록 상세 단계**

**[단계 0: 전제 조건 확인]**
*   **설명:** 이전 단계('사용자 입력 처리 로직 구현')에서 `var1`과 `var2`가 성공적으로 정수형(int)으로 변환되어 준비되었다고 가정합니다. 이 값들은 현재 유효성 검사가 되지 않은 상태입니다.
*   **예시:**
    ```python
    # 이전 단계에서 성공적으로 입력받았다고 가정하는 변수들
    var1 = 10
    var2 = 2
    # 또는
    # var1 = 1
    # var2 = 5
    ```

**[단계 1: 입력 값 유효성 검사 - 2 미만 여부 확인]**
*   **설명:** 소수를 판별하는 범위의 시작점은 최소 2부터이므로, 입력받은 두 정수 `var1`과 `var2`가 모두 2 이상의 값인지 확인합니다.
*   **구현 로직:** `var1` 또는 `var2` 중 하나라도 2보다 작은 경우를 조건으로 설정합니다.
*   **Python 코드 예시:**
    ```python
    if var1 < 2 or var2 < 2:
        # 단계 2에서 오류 처리 로직을 구현합니다.
        pass # 임시 placeholder
    ```

**[단계 2: 유효성 검사 실패 시 오류 처리]**
*   **설명:** 단계 1에서 유효성 검사에 실패한 경우 (즉, `var1` 또는 `var2` 중 하나라도 2 미만인 경우), 프로그램의 추가 진행을 막고 사용자에게 명확한 오류 메시지를 전달해야 합니다. 여기서는 `ValueError` 예외를 발생시켜 상위 호출자(calling context)가 이 예외를 처리하도록 합니다.
*   **구현 로직:** `if` 조건문 내에서 `ValueError` 예외를 발생시키고, 적절한 오류 메시지를 포함합니다.
*   **Python 코드 예시:**
    ```python
    if var1 < 2 or var2 < 2:
        raise ValueError("입력 값은 소수 판별을 위해 2 이상의 정수여야 합니다.")
    ```
*   **고려사항:** 만약 예외 발생 대신 사용자에게 재입력을 안내하는 로직이 필요하다면, 이 유효성 검사 로직을 `while` 루프와 `try-except` 블록으로 감싸서 구현할 수 있습니다. (이 작업 목록에서는 예외 발생을 기본으로 합니다.)

**[단계 3: 입력 값 정렬 및 `min_val`, `max_val` 할당]**
*   **설명:** 유효성 검사를 통과한 `var1`과 `var2`에 대해, 항상 `var1 <= var2`가 되도록 값을 정렬합니다. 이후 정렬된 작은 값을 `min_val`로, 큰 값을 `max_val`로 명명합니다. 이는 소수 개수를 세는 반복문의 범위를 설정할 때 `range(min_val, max_val + 1)` 형태로 사용하기 위함입니다.
*   **구현 로직:** Python의 내장 함수 `min()`과 `max()`를 사용하여 두 변수 중 작은 값과 큰 값을 각각 `min_val`과 `max_val`에 할당하는 것이 가장 간결하고 파이썬스러운 방법입니다.
*   **Python 코드 예시:**
    ```python
    # 유효성 검사를 통과한 후 실행됩니다.
    min_val = min(var1, var2)
    max_val = max(var1, var2)
    ```
*   **대안 로직 (수동 교환):**
    ```python
    # var1, var2를 직접 교환하는 방식도 가능하지만, min()/max()가 더 간결합니다.
    # if var1 > var2:
    #     var1, var2 = var2, var1 # 값 교환
    # min_val = var1
    # max_val = var2
    ```

**[단계 4: 결과 반환 또는 다음 단계로 전달]**
*   **설명:** 유효성 검사 및 정렬이 완료된 `min_val`과 `max_val`을 다음 로직(예: 소수 판별 및 개수 계산)에서 사용할 수 있도록 준비합니다. 일반적으로는 이 값들을 반환하거나, 다음 함수로 인자로 전달합니다.
*   **구현 로직:** 함수로 구현했을 경우 `min_val`, `max_val` 튜플을 반환합니다.
*   **Python 코드 예시:**
    ```python
    # 이 로직을 함수로 묶었을 때의 반환 예시
    return min_val, max_val
    ```

---

#### **통합 로직 예시 (함수 형태)**

위의 모든 단계를 통합하여 하나의 함수로 구현한 예시입니다.

```python
def validate_and_sort_inputs(var1: int, var2: int) -> tuple[int, int]:
    """
    사용자로부터 입력받은 두 정수에 대해 유효성 검사를 수행하고 정렬합니다.

    1. 입력 값이 2 이상의 정수인지 확인합니다.
    2. var1이 var2보다 큰 경우, 값을 교환하여 min_val <= max_val이 되도록 정렬합니다.
    3. 유효성 검사 실패 시 (예: 2 미만인 값), ValueError를 발생시킵니다.

    Args:
        var1 (int): 첫 번째 입력 정수.
        var2 (int): 두 번째 입력 정수.

    Returns:
        tuple[int, int]: 유효성 검사를 통과하고 정렬된 (min_val, max_val) 튜플.

    Raises:
        ValueError: 입력 값 중 하나라도 2 미만인 경우.
    """
    # 1. 입력 값 유효성 검사 (2 미만 여부 확인)
    if var1 < 2 or var2 < 2:
        # 2. 유효성 검사 실패 시 오류 처리
        raise ValueError("입력 값은 소수 판별을 위해 2 이상의 정수여야 합니다.")

    # 3. 입력 값 정렬 및 min_val, max_val 할당
    min_val = min(var1, var2)
    max_val = max(var1, var2)

    # 4. 결과 반환
    return min_val, max_val

# --- 로직 테스트 예시 ---
if __name__ == "__main__":
    print("--- 유효성 검사 및 정렬 로직 테스트 ---")

    # 성공 케이스 1: 정상적인 입력 (var1 < var2)
    try:
        v1, v2 = 10, 20
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"오류 발생: {e}")

    # 성공 케이스 2: 정상적인 입력 (var1 > var2, 정렬 필요)
    try:
        v1, v2 = 20, 10
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"오류 발생: {e}")

    # 성공 케이스 3: 경계값 (최소값 2 포함)
    try:
        v1, v2 = 2, 5
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"오류 발생: {e}")

    # 실패 케이스 1: var1이 2 미만
    try:
        v1, v2 = 1, 10
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"입력: ({v1}, {v2}) -> 오류 발생: {e}")

    # 실패 케이스 2: var2가 2 미만
    try:
        v1, v2 = 10, 0
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"입력: ({v1}, {v2}) -> 오류 발생: {e}")

    # 실패 케이스 3: 둘 다 2 미만
    try:
        v1, v2 = -5, 1
        min_v, max_v = validate_and_sort_inputs(v1, v2)
        print(f"입력: ({v1}, {v2}) -> 유효하고 정렬됨: (min_val={min_v}, max_val={max_v})")
    except ValueError as e:
        print(f"입력: ({v1}, {v2}) -> 오류 발생: {e}")
```
```

---

### 3. 소수 판별 함수(`is_prime`) 구현

- **ID**: `task_3`
- **상태**: `COMPLETED`
- **순서**: 3
- **설명**: 특정 숫자가 소수인지 판별하여 `True` 또는 `False`를 반환하는 함수 `is_prime(number)`를 구현합니다. 0, 1, 음수 등 소수가 아닌 예외 케이스를 처리하고, 효율적인 소수 판별 알고리즘(예: 제곱근까지만 확인)을 적용합니다.

**프롬프트**:
```
다음은 소수 개수 파악 로직 개발 프로젝트의 현재 작업입니다. 이전에 완료된 '사용자 입력 처리' 및 '입력 값 유효성 검사 및 정렬' 작업을 통해 `min_val`과 `max_val`이 이미 2 이상의 정수로 준비되었음을 참고하여, 아래 명시된 '소수 판별 함수(is_prime) 구현' 작업을 위한 상세 작업 목록을 Python 언어 기준으로 구체적이고 실행 가능한 단계로 생성해 주세요.

**현재 작업:**
-   **제목:** 소수 판별 함수(`is_prime`) 구현
-   **설명:** 특정 숫자가 소수인지 판별하여 `True` 또는 `False`를 반환하는 함수 `is_prime(number)`를 구현합니다. 0, 1, 음수 등 소수가 아닌 예외 케이스를 처리하고, 효율적인 소수 판별 알고리즘(예: 제곱근까지만 확인)을 적용합니다.

**프롬프트 요구사항:**
1.  작업을 정확하게 수행할 수 있어야 합니다.
2.  이전 작업의 결과를 참고할 수 있어야 합니다.
3.  구체적이고 실행 가능해야 합니다.
4.  코드 생성이 필요한 경우 적절한 언어와 프레임워크를 명시해야 합니다 (Python).
5.  단계별로 명확하게 설명되어야 합니다.

생성된 작업 목록은 함수 정의, 예외 처리 (0, 1, 음수), 효율적인 소수 판별 알고리즘 (제곱근 활용), 테스트 케이스 작성, 함수 문서화 등을 포함해야 합니다.
```

**결과**:
```
## 소수 판별 함수 (`is_prime`) 구현 상세 작업 목록

이 작업 목록은 Python 언어를 기반으로 `is_prime(number)` 함수를 구체적이고 실행 가능한 단계로 구현하고 테스트하는 과정을 안내합니다.

---

### **작업 제목:** 소수 판별 함수 (`is_prime`) 구현

### **목표:** 특정 숫자가 소수인지 판별하여 `True` 또는 `False`를 반환하는 `is_prime(number)` 함수를 구현하고, 0, 1, 음수 등 소수가 아닌 예외 케이스를 처리하며, 효율적인 소수 판별 알고리즘(제곱근까지만 확인)을 적용합니다.

---

### **상세 작업 목록:**

**단계 1: 함수 정의 및 기본 구조 설정**

1.  **Python 파일 생성:** `prime_checker.py`와 같은 이름으로 Python 파일을 생성합니다.
2.  **함수 시그니처 정의:** `is_prime` 함수의 기본 형태를 정의하고, 타입 힌트를 추가하여 입력 및 반환 값의 타입을 명확히 합니다.
    *   **코드 예시:**
        ```python
        import math # 제곱근 계산을 위해 math 모듈 임포트

        def is_prime(number: int) -> bool:
            """
            주어진 숫자가 소수인지 판별합니다.

            Args:
                number (int): 소수인지 판별할 정수.

            Returns:
                bool: 숫자가 소수이면 True, 아니면 False.
            """
            # 구현 내용이 여기에 들어갑니다.
            pass
        ```

**단계 2: 예외 및 특수 케이스 처리**

1.  **음수, 0, 1 처리:** 소수의 정의에 따라 음수, 0, 1은 소수가 아닙니다. 이 경우 즉시 `False`를 반환하도록 처리합니다.
    *   **코드 예시:**
        ```python
        # ... (이전 코드)
        def is_prime(number: int) -> bool:
            # 음수, 0, 1은 소수가 아님
            if number <= 1:
                return False
            # ... (다음 구현)
        ```
2.  **가장 작은 소수 2 처리:** 2는 유일한 짝수 소수이므로 특별히 처리합니다.
    *   **코드 예시:**
        ```python
        # ... (이전 코드)
            if number <= 1:
                return False
            # 2는 유일한 짝수 소수
            if number == 2:
                return True
            # ... (다음 구현)
        ```

**단계 3: 효율적인 소수 판별 알고리즘 구현**

1.  **짝수 처리 (2 제외):** 2를 제외한 모든 짝수는 소수가 아닙니다. 이 경우 즉시 `False`를 반환하여 불필요한 연산을 줄입니다.
    *   **코드 예시:**
        ```python
        # ... (이전 코드)
            if number == 2:
                return True
            # 2를 제외한 모든 짝수는 소수가 아님
            if number % 2 == 0:
                return False
            # ... (다음 구현)
        ```
2.  **제곱근까지만 확인:** 숫자가 `n`일 때, `n`의 약수는 `sqrt(n)`보다 작거나 같은 약수와 `sqrt(n)`보다 크거나 같은 약수가 쌍을 이룹니다. 따라서 `n`이 소수인지 판별하려면 `2`부터 `sqrt(n)`까지의 수로 나누어 떨어지는지 확인하면 됩니다. 홀수만 확인하는 최적화를 적용합니다.
    *   `math.isqrt()` 함수를 사용하여 정수 제곱근을 효율적으로 구합니다.
    *   `range(3, limit + 1, 2)`를 사용하여 3부터 시작하여 2씩 증가하며 홀수만 확인합니다.
    *   **코드 예시:**
        ```python
        # ... (이전 코드)
            if number % 2 == 0:
                return False

            # 3부터 숫자의 제곱근까지 홀수만 확인
            # math.isqrt는 정수 제곱근을 반환 (예: math.isqrt(9) -> 3, math.isqrt(10) -> 3)
            limit = math.isqrt(number)
            for i in range(3, limit + 1, 2): # 3부터 limit까지 2씩 증가 (홀수만 확인)
                if number % i == 0:
                    return False

            # 위 조건들을 모두 통과하면 소수
            return True
        ```

**단계 4: 함수 문서화 및 최종 검토**

1.  **Docstring 작성 완료:** 함수의 기능, 인자, 반환 값에 대한 설명을 포함하는 Docstring을 최종적으로 검토하고 필요 시 상세화합니다. (단계 1에서 작성된 Docstring 예시를 따릅니다.)
2.  **코드 가독성 검토:** 변수명, 주석, 코드 들여쓰기 등이 파이썬 PEP 8 가이드라인을 따르는지 확인하여 가독성을 높입니다.

**단계 5: 테스트 케이스 작성 및 실행**

1.  **테스트 블록 추가:** `prime_checker.py` 파일 내에 `if __name__ == "__main__":` 블록을 추가하여 함수를 테스트합니다.
2.  **다양한 테스트 케이스 정의:**
    *   **음수, 0, 1:** `is_prime(-5)`, `is_prime(0)`, `is_prime(1)` -> 모두 `False`
    *   **작은 소수:** `is_prime(2)`, `is_prime(3)`, `is_prime(5)`, `is_prime(7)` -> 모두 `True`
    *   **작은 합성수:** `is_prime(4)`, `is_prime(6)`, `is_prime(9)`, `is_prime(10)` -> 모두 `False`
    *   **큰 소수:** `is_prime(97)`, `is_prime(101)`, `is_prime(199)` -> 모두 `True`
    *   **큰 합성수:** `is_prime(100)`, `is_prime(121)`, `is_prime(999)` -> 모두 `False`
    *   **경계값:** `is_prime(math.isqrt(N) * math.isqrt(N))` 형태의 값 (예: `is_prime(49)`).
3.  **Assertion 또는 Print 문으로 결과 확인:** 각 테스트 케이스에 대해 예상 결과와 실제 함수 호출 결과가 일치하는지 확인합니다.
    *   **코드 예시:**
        ```python
        # ... (is_prime 함수 구현 완료)

        if __name__ == "__main__":
            print("--- is_prime 함수 테스트 시작 ---")

            # 예외 및 특수 케이스
            assert is_prime(-5) is False, "Test Case 1 Failed: -5"
            assert is_prime(0) is False, "Test Case 2 Failed: 0"
            assert is_prime(1) is False, "Test Case 3 Failed: 1"

            # 작은 소수
            assert is_prime(2) is True, "Test Case 4 Failed: 2"
            assert is_prime(3) is True, "Test Case 5 Failed: 3"
            assert is_prime(5) is True, "Test Case 6 Failed: 5"
            assert is_prime(7) is True, "Test Case 7 Failed: 7"

            # 작은 합성수
            assert is_prime(4) is False, "Test Case 8 Failed: 4"
            assert is_prime(6) is False, "Test Case 9 Failed: 6"
            assert is_prime(9) is False, "Test Case 10 Failed: 9"
            assert is_prime(10) is False, "Test Case 11 Failed: 10"

            # 큰 소수
            assert is_prime(97) is True, "Test Case 12 Failed: 97"
            assert is_prime(101) is True, "Test Case 13 Failed: 101"
            assert is_prime(199) is True, "Test Case 14 Failed: 199"
            assert is_prime(997) is True, "Test Case 15 Failed: 997"

            # 큰 합성수
            assert is_prime(100) is False, "Test Case 16 Failed: 100"
            assert is_prime(121) is False, "Test Case 17 Failed: 121 (11*11)"
            assert is_prime(999) is False, "Test Case 18 Failed: 999"
            assert is_prime(2000000000 - 1) is False, "Test Case 19 Failed: 2000000000 - 1 (even)" # 큰 짝수
            # 더 큰 소수 (예: 10억에 가까운 소수) - 테스트에 시간이 걸릴 수 있음
            # assert is_prime(999999937) is True, "Test Case 20 Failed: 999999937"

            print("모든 is_prime 테스트 케이스 통과!")
            print("--- is_prime 함수 테스트 종료 ---")
        ```
4.  **스크립트 실행:** 터미널에서 `python prime_checker.py` 명령어를 실행하여 테스트 결과를 확인합니다.

---

이 상세 작업 목록을 통해 `is_prime` 함수를 효율적이고 정확하게 구현할 수 있습니다. 다음 단계에서는 이 함수를 활용하여 주어진 범위 내의 소수를 찾는 로직을 개발하게 됩니다.
```

---

### 4. 주어진 범위 내 소수 개수 계산 로직 구현

- **ID**: `task_4`
- **상태**: `COMPLETED`
- **순서**: 4
- **설명**: Task 2에서 정렬된 범위(`min_val`부터 `max_val`까지) 내의 모든 숫자에 대해 Task 3의 `is_prime` 함수를 호출하고, 소수인 경우 카운터를 증가시키는 반복 로직을 구현합니다.

**프롬프트**:
```
주어진 정보를 바탕으로 '주어진 범위 내 소수 개수 계산 로직 구현' 작업을 위한 상세 작업 목록을 Python 언어 기준으로 구체적이고 실행 가능한 단계로 생성해 주세요. 이전 작업에서 `min_val`과 `max_val`이 유효성 검사 및 정렬되어 준비되었고, `is_prime(number)` 함수가 구현 및 테스트 완료되었다는 점을 참고하여, 이들을 활용하여 `min_val`부터 `max_val`까지의 범위에서 소수의 개수를 세는 반복 로직을 구현하는 데 초점을 맞춰주세요. 각 단계는 명확하게 설명되어야 합니다.
```

**결과**:
```
주어진 정보를 바탕으로 `min_val`부터 `max_val`까지의 범위에서 소수의 개수를 세는 반복 로직을 Python으로 구현하기 위한 상세 작업 목록입니다. `min_val`과 `max_val`은 이미 유효성 검사 및 정렬이 완료되었고, `is_prime(number)` 함수는 구현 및 테스트 완료되었다는 전제하에 진행됩니다.

---

## 작업 목표: 주어진 범위 내 소수 개수 계산 로직 구현

**전제 조건:**
*   `min_val`: 범위의 시작 값 (정수, 유효성 검사 및 정렬 완료)
*   `max_val`: 범위의 끝 값 (정수, 유효성 검사 및 정렬 완료, `min_val <= max_val`)
*   `is_prime(number)`: 특정 숫자가 소수인지 판별하는 함수 (구현 및 테스트 완료)

---

### 상세 작업 목록

#### 1. `count_primes_in_range` 함수 정의

**목표:** 소수 개수를 계산하는 로직을 캡슐화할 함수를 정의합니다.

**세부 단계:**
1.  **함수 시그니처 정의:** `min_val`과 `max_val`을 인자로 받는 `count_primes_in_range` 함수를 정의합니다.
2.  **Docstring 추가:** 함수의 목적, 인자, 반환 값에 대한 설명을 포함하는 Docstring을 작성하여 코드의 가독성과 유지보수성을 높입니다.

**예시 코드:**

```python
# is_prime 함수는 이미 구현되어 있다고 가정합니다.
# 예시:
def is_prime(number):
    if number < 2:
        return False
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False
    return True

def count_primes_in_range(min_val: int, max_val: int) -> int:
    """
    주어진 min_val부터 max_val(포함) 범위 내의 소수 개수를 계산합니다.

    Args:
        min_val (int): 범위의 시작 값. (유효성 검사 및 정렬 완료)
        max_val (int): 범위의 끝 값. (유효성 검사 및 정렬 완료, min_val <= max_val)

    Returns:
        int: 범위 내의 소수 개수.
    """
    # 다음 단계에서 구현될 로직이 여기에 들어갑니다.
    pass
```

#### 2. 소수 개수를 저장할 변수 초기화

**목표:** 범위 내에서 발견된 소수의 개수를 추적할 변수를 초기화합니다.

**세부 단계:**
1.  `prime_count`라는 이름의 변수를 0으로 초기화하여 시작합니다.

**예시 코드 (1단계에 이어서):**

```python
def count_primes_in_range(min_val: int, max_val: int) -> int:
    """
    ... (Docstring 생략) ...
    """
    prime_count = 0  # 소수 개수를 저장할 변수 초기화
    # ... (다음 단계 로직) ...
    return prime_count
```

#### 3. 범위 내 숫자 반복 (Looping)

**목표:** `min_val`부터 `max_val`까지의 모든 숫자를 순회하는 반복문을 구현합니다.

**세부 단계:**
1.  `for` 루프와 `range()` 함수를 사용하여 `min_val`부터 `max_val`까지의 숫자를 순차적으로 방문합니다.
    *   `range()` 함수는 끝 값을 포함하지 않으므로, `max_val`을 포함하려면 `max_val + 1`을 사용해야 합니다.

**예시 코드 (2단계에 이어서):**

```python
def count_primes_in_range(min_val: int, max_val: int) -> int:
    """
    ... (Docstring 생략) ...
    """
    prime_count = 0

    # min_val부터 max_val까지의 모든 숫자를 순회합니다.
    # range(start, end)는 start부터 end-1까지이므로, max_val을 포함하기 위해 max_val + 1 사용
    for number in range(min_val, max_val + 1):
        # ... (다음 단계 로직) ...
        pass # 이 부분에 소수 판별 로직이 들어갑니다.

    return prime_count
```

#### 4. 각 숫자에 대해 `is_prime` 함수 호출 및 개수 증가

**목표:** 반복문 내에서 각 숫자가 소수인지 확인하고, 소수일 경우 카운터를 증가시킵니다.

**세부 단계:**
1.  반복문 내에서 현재 숫자 `number`에 대해 `is_prime(number)` 함수를 호출합니다.
2.  `is_prime()` 함수가 `True`를 반환하면 (즉, `number`가 소수이면), `prime_count` 변수를 1 증가시킵니다.

**예시 코드 (3단계에 이어서):**

```python
def count_primes_in_range(min_val: int, max_val: int) -> int:
    """
    ... (Docstring 생략) ...
    """
    prime_count = 0

    for number in range(min_val, max_val + 1):
        if is_prime(number):  # is_prime 함수를 사용하여 소수인지 확인
            prime_count += 1  # 소수이면 카운터 증가

    return prime_count
```

#### 5. 결과 반환

**목표:** 모든 숫자를 확인한 후 최종 소수 개수를 반환합니다.

**세부 단계:**
1.  반복문이 완료된 후, `prime_count` 변수의 최종 값을 반환합니다. (이는 4단계 예시 코드에 이미 포함되어 있습니다.)

---

### 최종 구현 코드 (통합)

```python
# --- 전제 조건: is_prime 함수는 이미 구현 및 테스트 완료되었다고 가정합니다. ---
# 아래는 예시 is_prime 함수이며, 실제 사용 시에는 기존 구현체를 활용합니다.
def is_prime(number: int) -> bool:
    if number < 2:
        return False
    # 2부터 숫자의 제곱근까지 확인 (효율성)
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:
            return False
    return True
# --------------------------------------------------------------------------

def count_primes_in_range(min_val: int, max_val: int) -> int:
    """
    주어진 min_val부터 max_val(포함) 범위 내의 소수 개수를 계산합니다.

    Args:
        min_val (int): 범위의 시작 값. (유효성 검사 및 정렬 완료)
        max_val (int): 범위의 끝 값. (유효성 검사 및 정렬 완료, min_val <= max_val)

    Returns:
        int: 범위 내의 소수 개수.
    """
    prime_count = 0  # 1. 소수 개수를 저장할 변수 초기화

    # 2. min_val부터 max_val까지의 모든 숫자를 순회합니다.
    #    range(start, end)는 start부터 end-1까지이므로, max_val을 포함하기 위해 max_val + 1 사용
    for number in range(min_val, max_val + 1):
        # 3. 각 숫자에 대해 is_prime 함수를 호출하여 소수인지 확인
        if is_prime(number):
            prime_count += 1  # 4. 소수이면 카운터 증가

    return prime_count  # 5. 최종 소수 개수 반환
```

### 6. 테스트 및 검증

**목표:** 구현된 `count_primes_in_range` 함수가 올바르게 작동하는지 확인합니다.

**세부 단계:**
1.  **다양한 테스트 케이스 준비:**
    *   **기본 케이스:** `min_val = 1, max_val = 10` (기대값: 2, 3, 5, 7 -> 4개)
    *   **작은 범위:** `min_val = 1, max_val = 2` (기대값: 2 -> 1개)
    *   **소수만 포함:** `min_val = 2, max_val = 3` (기대값: 2, 3 -> 2개)
    *   **소수 없음:** `min_val = 8, max_val = 10` (기대값: 0개)
    *   **큰 범위:** `min_val = 10, max_val = 50` (기대값: 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 -> 11개)
    *   **min_val이 소수가 아닌 경우:** `min_val = 1, max_val = 1` (기대값: 0개)
    *   **min_val이 0인 경우:** `min_val = 0, max_val = 5` (기대값: 2, 3, 5 -> 3개)
2.  **함수 호출 및 결과 출력:** 각 테스트 케이스에 대해 함수를 호출하고 반환된 값을 출력합니다.
3.  **결과 비교:** 출력된 결과가 예상값과 일치하는지 수동 또는 자동화된 방식으로 확인합니다.

**예시 테스트 코드:**

```python
print(f"Primes between 1 and 10: {count_primes_in_range(1, 10)}")  # 예상: 4
print(f"Primes between 1 and 2: {count_primes_in_range(1, 2)}")    # 예상: 1 (2)
print(f"Primes between 2 and 3: {count_primes_in_range(2, 3)}")    # 예상: 2 (2, 3)
print(f"Primes between 8 and 10: {count_primes_in_range(8, 10)}")  # 예상: 0
print(f"Primes between 10 and 50: {count_primes_in_range(10, 50)}")# 예상: 11
print(f"Primes between 1 and 1: {count_primes_in_range(1, 1)}")    # 예상: 0
print(f"Primes between 0 and 5: {count_primes_in_range(0, 5)}")    # 예상: 3 (2, 3, 5)
```

---

이 상세 작업 목록은 `min_val`과 `max_val`의 유효성 검사 및 `is_prime` 함수 구현이 완료되었다는 전제하에, 소수 개수를 세는 핵심 반복 로직을 구현하는 데 필요한 모든 구체적이고 실행 가능한 단계를 제공합니다.
```

---

### 5. 결과 출력 로직 구현

- **ID**: `task_5`
- **상태**: `COMPLETED`
- **순서**: 5
- **설명**: Task 4에서 계산된 최종 소수 개수 값을 사용자에게 명확하게 출력하는 기능을 구현합니다.

**프롬프트**:
```
당신은 "변수 1, 2를 입력받아서 그 사이에 존재하는 소수의 갯수를 파악하는 로직" 프로젝트의 개발 리더입니다.

이전에 완료된 작업들은 다음과 같습니다:
1.  **사용자 입력 처리 로직 구현**: 사용자로부터 `var1`, `var2`를 입력받는 기능이 구현되었습니다.
2.  **입력 값 유효성 검사 및 정렬 로직 구현**: 입력받은 `var1`, `var2`가 유효한 정수인지 검사하고, 항상 `min_val <= max_val`이 되도록 정렬하여 `min_val`과 `max_val`을 준비하는 기능이 구현되었습니다.
3.  **소수 판별 함수(`is_prime`) 구현**: 특정 숫자가 소수인지 판별하여 `True` 또는 `False`를 반환하는 `is_prime(number)` 함수가 구현 및 테스트되었습니다.
4.  **주어진 범위 내 소수 개수 계산 로직 구현**: `min_val`부터 `max_val`까지의 범위에서 `is_prime` 함수를 사용하여 소수의 개수를 세고, 최종 소수 개수 값을 산출하는 기능이 구현되었습니다.

현재 작업은 **"결과 출력 로직 구현"**입니다.
**설명:** Task 4에서 계산된 최종 소수 개수 값을 사용자에게 명확하게 출력하는 기능을 구현합니다. 이 출력은 사용자가 입력한 원래 범위(`min_val`, `max_val`)와 함께 제공되어야 합니다.

Python 언어를 사용하여 이 작업을 위한 구체적이고 실행 가능한 단계별 작업 목록을 생성해주세요. 각 단계는 명확하게 설명되어야 하며, 최종 소수 개수와 입력 범위(`min_val`, `max_val`)를 사용자에게 친절하고 이해하기 쉽게 보여주는 방법에 초점을 맞춰야 합니다.
```

**결과**:
```
## [프로젝트] 변수 범위 내 소수 개수 파악 - 개발 리더 지시사항

**현재 작업: "결과 출력 로직 구현"**

팀원 여러분, 이전 단계까지 성공적으로 완료해 주셔서 감사합니다. 이제 마지막 단계인 "결과 출력 로직 구현"을 통해 사용자가 입력한 범위 내에서 계산된 소수의 개수를 명확하고 친절하게 전달하는 기능을 완성할 차례입니다.

이 작업은 `min_val`, `max_val` (유효성 검사 및 정렬이 완료된 범위 값)과 Task 4에서 계산된 최종 소수 개수 (`prime_count`라고 가정)를 활용하여 사용자에게 최종 결과를 보여주는 데 중점을 둡니다.

---

### Python 언어를 사용한 "결과 출력 로직 구현" 단계별 작업 목록

다음은 이 작업을 위한 구체적이고 실행 가능한 단계별 작업 목록입니다.

#### 1. 결과 출력 함수 또는 섹션 정의 (선택 사항이지만 권장)
*   **목표:** 메인 로직과 출력 로직을 분리하여 코드의 가독성과 유지보수성을 높입니다.
*   **설명:** 최종 `prime_count`, `min_val`, `max_val` 값을 인자로 받아 출력 메시지를 생성하고 화면에 표시하는 전용 함수를 정의하거나, 메인 스크립트의 마지막 부분에 출력 전용 섹션을 명확히 구분합니다.
*   **예시 (함수 정의 시):**
    ```python
    def display_results(min_val, max_val, prime_count):
        # 여기에 출력 로직 구현
        pass
    ```

#### 2. 출력 메시지 구성
*   **목표:** `min_val`, `max_val`, `prime_count`를 포함하여 사용자에게 결과를 명확하게 설명하는 문자열을 생성합니다.
*   **설명:** Python의 f-string(Formatted String Literals)을 사용하여 변수 값을 문자열에 삽입하면 가독성이 높고 간결하게 메시지를 만들 수 있습니다. 사용자가 이해하기 쉽도록 문맥을 제공하는 것이 중요합니다.
*   **고려 사항:**
    *   "입력하신 범위", "총 N개의 소수"와 같은 표현을 사용하여 친절함을 더합니다.
    *   `min_val`과 `max_val`이 동일한 경우(예: `[5, 5]`)에도 자연스러운 메시지가 되도록 합니다.
    *   소수가 0개인 경우에도 어색하지 않은 메시지가 되도록 합니다.
*   **예시:**
    ```python
    # display_results 함수 내부 또는 메인 로직 마지막 부분
    output_message = f"입력하신 범위 {min_val}부터 {max_val}까지 (inclusive) 총 {prime_count}개의 소수가 존재합니다."
    ```
    또는
    ```python
    if prime_count > 0:
        output_message = f"입력하신 범위 {min_val}부터 {max_val}까지 (inclusive) 총 {prime_count}개의 소수를 찾았습니다."
    else:
        output_message = f"입력하신 범위 {min_val}부터 {max_val}까지 (inclusive) 소수가 존재하지 않습니다."
    ```

#### 3. 결과 출력
*   **목표:** 구성된 메시지를 사용자에게 보여줍니다.
*   **설명:** `print()` 함수를 사용하여 구성된 `output_message`를 표준 출력(콘솔)으로 보냅니다.
*   **예시:**
    ```python
    print("\n--- 소수 개수 분석 결과 ---") # 시각적인 구분선 추가
    print(output_message)
    print("-------------------------\n")
    ```

#### 4. 프로그램 종료 메시지 (선택 사항)
*   **목표:** 프로그램이 정상적으로 작업을 완료했음을 사용자에게 알립니다.
*   **설명:** 사용자 경험을 개선하기 위해 작업 완료 후 간단한 종료 메시지를 추가할 수 있습니다.
*   **예시:**
    ```python
    print("작업이 완료되었습니다. 이용해 주셔서 감사합니다!")
    ```

#### 5. 테스트 및 검증
*   **목표:** 다양한 시나리오에서 출력 로직이 올바르게 작동하는지 확인합니다.
*   **설명:**
    *   **양의 소수 개수:** `min_val=1, max_val=10` (4개 소수: 2, 3, 5, 7)
    *   **소수 개수 0:** `min_val=1, max_val=1` 또는 `min_val=4, max_val=4`
    *   **단일 숫자 범위:** `min_val=7, max_val=7` (1개 소수: 7)
    *   **큰 범위:** `min_val=100, max_val=200` (21개 소수)
    *   **음수 또는 0 포함 (입력 유효성 검사 단계에서 이미 처리되었겠지만, 최종 min/max_val이 음수가 되지 않는지 확인):** `min_val`과 `max_val`은 항상 1 이상의 정수여야 합니다. 이 단계에서는 이미 `min_val >= 1`이 보장된다고 가정합니다.

---

### 최종 구현 예시 (전체 로직의 마지막 부분)

```python
# --- 이전 단계에서 계산된 값들이 여기에 있다고 가정 ---
# min_val = 5 # 예시 값
# max_val = 20 # 예시 값
# prime_count = 6 # 예시 값 (5, 7, 11, 13, 17, 19)

def display_prime_count_results(min_val, max_val, prime_count):
    """
    주어진 범위 내 소수 개수를 사용자에게 출력하는 함수.
    """
    print("\n" + "="*40)
    print("          소수 개수 분석 결과")
    print("="*40)

    # 출력 메시지 구성
    if prime_count > 0:
        message = f"입력하신 범위 [{min_val}, {max_val}] 내에 총 {prime_count}개의 소수가 존재합니다."
    else:
        message = f"입력하신 범위 [{min_val}, {max_val}] 내에는 소수가 존재하지 않습니다."

    # 결과 출력
    print(message)

    print("-" * 40)
    print("작업이 완료되었습니다. 이용해 주셔서 감사합니다!")
    print("="*40 + "\n")

# --- 실제 프로그램 흐름에서 호출되는 방식 ---
# (가상의 min_val, max_val, prime_count 변수 사용)
# display_prime_count_results(min_val, max_val, prime_count)

# --- 테스트를 위한 호출 예시 ---
# display_prime_count_results(1, 10, 4)  # 2,3,5,7
# display_prime_count_results(1, 1, 0)
# display_prime_count_results(7, 7, 1)
# display_prime_count_results(100, 200, 21)
```

---

이 작업 목록을 바탕으로 "결과 출력 로직"을 구현해 주십시오. 깔끔하고 사용자 친화적인 출력을 기대합니다! 궁금한 점이 있다면 언제든지 질문해주세요.
```

## 요약

- 총 작업 수: 5
- 완료된 작업: 5
- 취소된 작업: 0
- 실패한 작업: 0
- 진행률: 100%
